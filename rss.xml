<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Recordum]]></title><description><![CDATA[All about Recordum]]></description><link>http://acyort.am0200.com</link><generator>RSS for Node</generator><lastBuildDate>Fri, 22 Dec 2017 14:24:00 GMT</lastBuildDate><atom:link href="http:/acyort.am0200.com/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 22 Dec 2017 14:23:58 GMT</pubDate><item><title><![CDATA[js 使用 setTimeout 排序]]></title><description><![CDATA[<p>原理就是将要排序的数组的每一个项作为 <code>setTimeout</code> 时间参数，然后就可以排序了</p>
<p>排序时间跟数组最大值绝对值有关 :)</p>
<p>需要对数组的负数项做一下处理，因为 <code>setTimeout</code> 参数负数的话跟参数 0 是一样的</p>
<p>例子 <a href="https://jsfiddle.net/am0200/o0sz55pq/">JSFiddle</a></p>
<p>具体代码说明:</p>
<pre><code>&#x2F;&#x2F; 需要排序数组
const numbers &#x3D; [8, 0, 3, -1, 9, -3, -767, 4, 111, 999, 89];

async function sortArr(arr) {
  const left &#x3D; arr.filter(a &#x3D;&gt; a &lt; 0).map(a &#x3D;&gt; a * -1) &#x2F;&#x2F; 获取数组负数项并转成正数
  const right &#x3D; arr.filter(a &#x3D;&gt; a &gt;&#x3D; 0) &#x2F;&#x2F; 数组正数项
  const sortLeft &#x3D; (await sort(left)).map(a &#x3D;&gt; a * -1).reverse() &#x2F;&#x2F; 负数项排序后需要反向
  const sortRight &#x3D; await sort(right) &#x2F;&#x2F; 正数项排序

  return sortLeft.concat(sortRight)
} 

function sort(arr) {
  return new Promise((resolve) &#x3D;&gt; {
    let len &#x3D; arr.length
    const back &#x3D; []

    arr.forEach(item &#x3D;&gt; {
      setTimeout(() &#x3D;&gt; {
        back.push(item)
        len -&#x3D; 1
        if (len &#x3D;&#x3D;&#x3D; 0) {
          resolve(back) &#x2F;&#x2F; 完成排序
        }
      }, item) &#x2F;&#x2F; 以每个项作为时间
    })
  })
}

;(async () &#x3D;&gt; {
  document.body.innerHTML &#x3D; &#39;Before: &#39; + numbers.join(&#39;, &#39;) + &#39;&lt;br&gt;After: &#39; + (await sortArr(numbers)).join(&#39;, &#39;)
})()

&#x2F;&#x2F; 排序结果: [-767, -3, -1, 0, 3, 4, 8, 9, 89, 111, 999]</code></pre><p>最后说明一下，这只是一种特别的排序方式，请不要去纠结效率时间等其他问题</p>
]]></description><link>http:/acyort.am0200.com/posts/244718742.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/244718742.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 16 Dec 2017 07:07:48 GMT</pubDate></item><item><title><![CDATA[AcyOrt - 基于 Node.js 博客生成程序]]></title><description><![CDATA[<p>AcyOrt 是一个基于 Node.js 的博客工具。通过这个工具，用户只要在 issues 上写自己的博客文章，然后一个简单命令就可以产生博客内容。</p>
<p>&lt;!-- more --&gt;
</p>
<p>项目地址：<a href="https://github.com/acyortjs/acyort">https://github.com/acyortjs/acyort</a></p>
<h2>特色说明</h2><p>对比 Hexo，基本上的功能都有了，也差不多。这里主要说一下特别的地方</p>
<h3>多用户支持</h3><p>允许多用户创造，特别适合团队写作，写作用户只要要一个 Github 账号即可。很多大神的 issue 博客就会老是会有人在上面写一些无关内容。只要指定特定写作人，就可以排除掉其他人的无关内容了</p>
<h3>写作方便</h3><p>基本上是最简单最舒服的写作方式了，直接在 issue 上写博客，借助 GitHub 强大的 markdown 写作工具，连上传图片都是那么的简单拖放即可，仅仅需要联网浏览器即可</p>
<h3>博客数据</h3><p>因为是存放在 GitHub 上，不用担心数据丢失问题，也不用考虑那些 md 文件要保存在哪里，以及迁移问题</p>
<h3>简单安装配置</h3><p>和 hexo 不同，AcyOrt 只需要 npm 全局安装一次，就可以到处使用了。</p>
<p>不需要新建一次博客就还要 <code>npm install</code> 一次，一个简单的 <code>acyort init</code> 命令就可以生成一个新的博客了。</p>
<p>配置文件也只有一个 <code>config.yml</code>，保存所有配置</p>
<h3>自动构建</h3><p>AcyOrt 支持 Travis Ci 自动构建，效果就是你在 issue 上写完博客，然后在 GitHub 上点击一个按钮，然后你的博客就更新了。</p>
<p>不需要 git 操作，不需要自己搭建服务器，也不需要在你本地机器上生成，全程云端生成</p>
<p>参考：<a href="https://github.com/acyortjs/acyortjs.github.io/issues/13">https://github.com/acyortjs/acyortjs.github.io/issues/13</a> </p>
<p>以及还有一个视频演示：链接: <a href="https://pan.baidu.com/s/1c2rdynQ">https://pan.baidu.com/s/1c2rdynQ</a> 密码: 6q8q</p>
<p>甚至你还可以弄一个 webhook，保存 issue 博客同时就可以自动更新博客，什么都不用做。参考这里：<a href="https://github.com/acyortjs/webhook">https://github.com/acyortjs/webhook</a></p>
<h3>主题模板相关</h3><p>模板基于 <code>swig</code>，集成 <code>liveReload</code>，自动刷新页面，方便主题修改</p>
<h3>JSON 输出</h3><p>同时支持 json 输出博客内容，方便各种需求</p>
<h2>相关 demo</h2><p>一个例子：<a href="http://acyort.am0200.com/">http://acyort.am0200.com/</a></p>
<p>基于 JSON：<a href="http://aksdj4.am0200.com/">http://aksdj4.am0200.com/</a></p>
<h2>已实现功能</h2><ul>
<li>文章功能</li>
<li>评论功能</li>
<li>RSS 输出</li>
<li>页面功能</li>
<li>标签功能</li>
<li>分类功能</li>
<li>主题功能</li>
<li>封面图</li>
<li>文章目录</li>
<li>多语言支持</li>
</ul>
<h2>安装使用说明</h2><p>安装说明：<a href="https://github.com/acyortjs/acyort#readme">https://github.com/acyortjs/acyort#readme</a></p>
<p>相关文档：<a href="https://github.com/acyortjs/acyortjs.github.io/issues">https://github.com/acyortjs/acyortjs.github.io/issues</a></p>
<h2>后续功能及说明</h2><ul>
<li>插件支持</li>
<li>单元测试</li>
<li>项目网站</li>
</ul>
<p>由于功能还没有完全开发完成，一些功能还在修改当中，所以单元测试还没有弄，相关的支持网站相关也在陆续添加</p>
]]></description><link>http:/acyort.am0200.com/posts/225371660.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/225371660.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 16 Dec 2017 07:08:03 GMT</pubDate></item><item><title><![CDATA[Vue JSON 博客(AcyOrt/Vue/Vuex/Webpack)]]></title><description><![CDATA[<p>尝试使用 <a href="https://github.com/acyortjs/acyort">AcyOrt </a> 的 JSON 输出功能构建一个博客，顺便用了 vue + webpack 组合开发。</p>
<p>DEMO: <a href="http://aksdj4.am0200.com/">http://aksdj4.am0200.com/</a></p>
<p>项目地址: <a href="https://github.com/acyortjs/aksdj4">https://github.com/acyortjs/aksdj4</a></p>
<h3>内容 JSON</h3><p>使用  <a href="https://github.com/acyortjs/acyort">AcyOrt </a> 将项目 <a href="https://github.com/LoeiFy/Recordum/issues">Recordum</a> issue 生成 JSON: <a href="https://github.com/acyortjs/aksdj4/tree/gh-pages/json">https://github.com/acyortjs/aksdj4/tree/gh-pages/json</a></p>
<h3>开发选择</h3><p>基于 webpack 2 + vue 2，值得注意的是 <code>vue-loader</code> 已经包含了 <code>vue-hot-reload-api</code>, <code>vue-style-loader</code>，甚至 postcss，所以 vue 相关的 loader 只需要安装 <code>vue-loader</code>, <code>vue-template-compiler</code></p>
<blockquote>
<p>ES6</p>
</blockquote>
<p>因为我并没有用到很多 ES7 以上的特性，只用到 <code>Object rest spread</code> 所以 babel 插件选择了
<code>babel-plugin-transform-object-rest-spread</code>, <code>babel-preset-es2015</code></p>
<blockquote>
<p>CSS 预处理器</p>
</blockquote>
<p>这次使用了 <code>postcss</code>，没有选择 <code>sass</code>，因为不需要安装那么久，并且加上对应插件也类似的写法，选择插件有：<code>postcss-cssnext</code>, <code>postcss-import</code>。这里也不需要安装 <code>Autoprefixer</code>，因为 cssnext 自带了</p>
<blockquote>
<p>vue 相关</p>
</blockquote>
<p>使用了 vue/vue-router/vuex/，没有用 <code>vue-resource</code>，选择了 <code>axios</code>，作者也推荐用 axios: <a href="https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4">https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4</a></p>
<h3>项目构建</h3><p>有几个构建要求，分离相关基础库，修改 js，css 互不影响缓存</p>
<blockquote>
<p>分离 css</p>
</blockquote>
<p>使用 <code>webpack-md5-hash</code> 插件，使用 <code>contenthash</code> 文件名，保证修改 js 不会影响 css</p>
<pre><code>loaders: {
  postcss: ExtractTextPlugin.extract({
    use: [
      {
        loader: &#39;css-loader&#39;,
        options: {
          minimize: true
        }
      },
      &#39;postcss-loader&#39;
    ],
    fallback: &#39;vue-style-loader&#39;
  })
}
...
new ExtractTextPlugin(&#39;[name].[contenthash:8].css&#39;)</code></pre><blockquote>
<p>提取公共库</p>
</blockquote>
<p>基本上不会修改这些基础库</p>
<pre><code>{
  entry: {
    vendors: [&#39;axios&#39;, &#39;vue&#39;, &#39;vuex&#39;, &#39;vue-router&#39;]
  }
}
...
new webpack.optimize.CommonsChunkPlugin({
  names: [&#39;vendors&#39;, &#39;manifest&#39;]
})</code></pre><p>使用 <code>html-webpack-plugin</code> 进行自动生成相应资源路径，然后生成的 html 会有 4 个资源路径</p>
<pre><code>...
&lt;link href&#x3D;&quot;&#x2F;build.0570f616.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;
...
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;manifest.d41d8cd9.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;vendors.a2c4ab5a.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;build.be4b1392.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p>这里有个问题，虽然现在修改 js，css 文件不会改变，反过来 css 修改 js 也不会改变，但是每次生成的 manifest.xxxxxx.js 可能文件名不一样，但是内容也变化了，这里有一个 issue: <a href="https://github.com/erm0l0v/webpack-md5-hash/issues/9">https://github.com/erm0l0v/webpack-md5-hash/issues/9</a></p>
<p>并且这个 manifest.js 是很小的，纪录一些打包模块信息，单独出来产生一个请求觉得不太好，所以这里选择将这个文件 inject 到 html，这样也可以不管上面所说的文件不一致问题</p>
<p>使用 <code>html-webpack-inline-source-plugin</code> 将 manifest inline 到 index.html</p>
<pre><code>new HtmlWebpackPlugin({
  template: &#39;src&#x2F;index.html&#39;,
  inject: &#39;body&#39;,
  inlineSource: &#39;manifest+&#39; &#x2F;&#x2F; 将 manifest 开头的 inline script
})</code></pre><h3>路由选择</h3><p>vue-router 也有两种路由模式选择，hash 模式以及 history 模式，history 模式需要服务器支持。因为项目是寄存在 GitHub pages 上，不能配置服务器，但这里还是使用了 history 模式，参考这里: <a href="https://github.com/LoeiFy/Recordum/issues/15">https://github.com/LoeiFy/Recordum/issues/15</a></p>
<p>因为 GitHub pages 支持 404.html，所以直接将生成的 index.html 复制生成一份 404.html，那么访问不存在路径就直接访问 404.html，就相当于访问 index.html，虽然这时候的 http code 是 404，但整个项目功能并没有受到影响</p>
]]></description><link>http:/acyort.am0200.com/posts/223304114.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/223304114.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 16 Dec 2017 07:08:17 GMT</pubDate></item><item><title><![CDATA[不依赖服务端实现 react-router 的 browserHistory]]></title><description><![CDATA[<p>SPA 项目基本上都会用到路由 <code>router</code>。react 还有 vue 对应有其路由插件。 react-router 还有 vue-router 都有 hashHistory 和 browserHistory 模式。这里大概说一下两者区别</p>
<p>&lt;!-- more --&gt;
</p>
<ul>
<li>hashHistory: 不需要服务器配置，在 URL 生成一个 hash 来跟踪状态，通常在测试环境使用，也可以作为发布环境使用</li>
<li>browserHistory: 需要服务器端做配置，路径是真实的URL，是 react-router 官方推荐首选</li>
</ul>
<p>大多数情况下，browserHistory 模式明显是优于 hashHistory 模式的，但 browserHistory 需要一定的配置</p>
<h3>一般方式</h3><p>可以看出，hashHistory 不需要什么配置，但 browserHistory 需要服务端支持，这里简单说一下两种方式做支持，其它方式基本上都是类似</p>
<blockquote>
<p>使用 express</p>
</blockquote>
<pre><code>const app &#x3D; express()
app.get(&#39;*&#39;, function (request, response){
  response.sendFile(path.resolve(__dirname, &#39;index.html&#39;))
})</code></pre><blockquote>
<p>使用 nginx</p>
</blockquote>
<pre><code>server {
  ...
  location &#x2F; {
    try_files $uri &#x2F;index.html
  }
}</code></pre><p>这里说明一下为什么要这样设置，browserHistory 模式下，URL 是指向真实 URL 的资源路径，当通过真实 URL 访问网站的时候（首页），这个时候可以正常加载我们的网站资源，而用户在非首页下手动刷新网页时，由于路径是指向服务器的真实路径，但该路径下并没有相关资源，用户访问的资源不存在，返回给用户的是 404 错误</p>
<h3>另一种方式</h3><p>通过上面所说的原理，简单起来说就是 browserHistory 模式下，需要每个路由下都要有对应的资源存在，就不会产生 404 错误，所以如果不借助服务端的话，又要实现这种模式，这种场景在自己不能配置服务器时候会碰到，例如把项目部署到 <code>GitHub pages</code> 上。那该怎么办呢</p>
<blockquote>
<p>那么就产生 <strong>对应资源</strong> </p>
</blockquote>
<p>所以，我们的做法就是在每个 <strong>路由路径</strong> 下，都放置一个跟首页一样的 <code>index.html</code></p>
<p>下面是做法，当然也是有各种方式的，都是可以类推的</p>
<p>假定我们有以下的路由设定，这里以 react-router 为例子</p>
<pre><code>export default (
  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;{App}&gt;
    &lt;IndexRoute component&#x3D;{HomePage} &#x2F;&gt;
    &lt;Route path&#x3D;&quot;contact-us&quot; component&#x3D;{ContactPage} &#x2F;&gt;
    &lt;Route path&#x3D;&quot;dashboard&quot;&gt;
      &lt;IndexRoute component&#x3D;{Verify(Dashboard)} &#x2F;&gt;
      &lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;{Verify(Inbox)} &#x2F;&gt;
      &lt;Route path&#x3D;&quot;conversation&quot; component&#x3D;{Verify(ComposeMessage)} &#x2F;&gt;
    &lt;&#x2F;Route&gt;
    &lt;Route path&#x3D;&quot;*&quot; component&#x3D;{NotFound} &#x2F;&gt;
  &lt;&#x2F;Route&gt;
)</code></pre><p>那么就可以路由路径为</p>
<pre><code>&#x2F;&#x2F; routes.js
const routes &#x3D; [
  &#39;contact-us&#39;,
  &#39;dashboard&#39;,
  &#39;dashborad&#x2F;inbox&#39;,
  &#39;dashboard&#x2F;conversation&#39;
]

module.exports &#x3D; routes</code></pre><p>接下来我们就把生成的 <code>index.html</code> 复制到这几个路径下就可以了</p>
<pre><code>&#x2F;&#x2F; deploy.js
const fs &#x3D; require(&#39;fs-extra&#39;)
const routes &#x3D; require(&#39;routes.js&#39;)
const path &#x3D; require(&#39;path&#39;)
routes.forEach((route) &#x3D;&gt; {
  fs.copySync(&#39;index.html&#39;, path.join(route, &#39;index.html&#39;))
})</code></pre><p>这样用户访问就不会出现 404 了，SPA 的功能也不受影响，为了方便我们可以把这个生成工具集成到 <code>package.json</code></p>
<pre><code>{
  &quot;script&quot;: {
    &quot;build&quot;: &quot;NODE_ENV&#x3D;production webpack --progress &amp;&amp; node deploy.js&quot;
  }
}</code></pre><p>ok, 当我们运行 <code>npm run build</code> 时候，就会同时生成对应路径下的 <code>index.html</code>，这样就可以了完成我们所需要的功能了</p>
<h3>问题 &amp; 思考</h3><blockquote>
<p>404 页面问题</p>
</blockquote>
<p>这个就直接使用服务端 404 页面了，如果是用 <code>GitHub pages</code> 的话，我们可以直接生成一个 <code>404.html</code> 即可。或者是将 404 路由跳转到首页</p>
<p>还有一种做法，直接把 404 页面弄成跟 index 内容一样，404 时候就是正常的内容页面，这时候页面功能是正常的，并且不需要前面的一对做法了。</p>
]]></description><link>http:/acyort.am0200.com/posts/210285498.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/210285498.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 16 Dec 2017 07:08:26 GMT</pubDate></item><item><title><![CDATA[记录一下折腾黑苹果过程]]></title><description><![CDATA[<p>也算是完成了读书时候的心愿，以前读书时候老想着弄个黑苹果，但是一直没有成功。最近折腾安装前后花的时间就两三天那样，参考了一堆前人经验，所以不会很折腾，总体上算是完美的</p>
<p>&lt;!-- more --&gt;
</p>
<h2>黑苹果情况</h2><p><img src="https://cloud.githubusercontent.com/assets/2193211/22615077/d8cde9de-eac7-11e6-98be-6531cc36bc61.png" alt="screen shot 2017-02-04 at 10 30 35 am"></p>
<h3>正常部分</h3><ul>
<li>显卡(HD530)，声卡，网卡驱动正常</li>
<li>USB 3 识别正常</li>
<li>CPU 可以变频</li>
<li>SSD TRIM 正常</li>
</ul>
<h3>问题</h3><ul>
<li>不能休眠/睡眠，因为是台式机，不理会</li>
<li>开机偶尔会出现禁止符号，拔掉/换接口 usb 就可以，应该是 usb 驱动问题吧，经常不关机不理会</li>
<li>开机过程会有一瞬间花屏现象，不影响使用，不理会</li>
</ul>
<h2>机器配置</h2><ul>
<li>CPU: i5-6500 散 </li>
<li>主板: 微星 B150i GAMING PRO </li>
<li>内存: 金士顿 8G*2 </li>
<li>显卡: 内置集显</li>
<li>机箱: 迎广肖邦</li>
<li>电源: 机箱内置 </li>
<li>SSD: Crucial_CT960M500 (之前没有用到的) </li>
</ul>
<h2>安装过程</h2><p>主要参考：<a href="https://www.tonymacx86.com/threads/unibeast-install-macos-sierra-on-any-supported-intel-based-pc.200564/">https://www.tonymacx86.com/threads/unibeast-install-macos-sierra-on-any-supported-intel-based-pc.200564/</a></p>
<p>需要 3 个软件 <code>UniBeast</code>, <code>MultiBeast</code>, <code>Clover Configurator</code></p>
<p>usb 启动盘相关都是在 MacBook air 上操作的，教程上制作软件需要在英文系统下操作</p>
<h3>BIOS 设置</h3><ul>
<li><p>settings\高级\整合周边设备： SATA模式 - AHCI模式</p>
</li>
<li><p>settings\高级\USB设置： XHCI Hand-off - 允许</p>
</li>
<li><p>settings\高级\超级IO配置\串口0配置： 串口0 - 禁止</p>
</li>
<li><p>settings\启动： 启动模式选择 - UEFI</p>
</li>
<li><p>Overclocking\CPU 特征： CFG 锁定 - 禁止</p>
</li>
<li><p><del>Overclocking\CPU 特征： Intel 虚拟化技术 - 禁止 ／ Intel VT-D 技术 - 禁止</del></p>
</li>
</ul>
<h3>UniBeast 制作安装启动盘</h3><ul>
<li>格式化 U 盘：USB/OS X Extended (Journaled)/GUID Partition Map</li>
<li>写入 macOS Sierra 镜像，过程有点长，慢慢等</li>
</ul>
<p>安装完成将需要的设置软件 <code>MultiBeast</code>, <code>Clover Configurator</code> 拖入 U 盘保存，后续需要</p>
<h3>安装系统</h3><ul>
<li>开机 F11 选择 U 盘启动</li>
<li>磁盘工具格式化硬盘：Sierra/OS X Extended (Journaled)/GUID Partition Map</li>
<li>安装，然后提示重启</li>
<li>重启后选择 U 盘启动，启动刚刚安装的 Sierra，继续完成安装</li>
</ul>
<h3>系统设置</h3><p>完成安装后，这时候系统还没有相关驱动，打开相应软件进行设置</p>
<blockquote>
<p>使用 <code>MutiBeast</code> 进行驱动相关设置</p>
</blockquote>
<ul>
<li>Quick Start: UEFI Boot Mode</li>
<li>Audio: Realtek ALCxxx - ALC887/888b, Optional HD 3000/HD 4000/HD 530 HDMI Audio</li>
<li>Network: Realtek - RealtekRTL8111 v2.2.1</li>
<li>Graphics Configuration: Intel HD 530</li>
<li>SSDT Options: Sandy Bridge Core i5</li>
</ul>
<blockquote>
<p>plist 设置</p>
</blockquote>
<p>使用 <code>Clover Configurator</code> mount EFI 分区，用 sublime 打开 EFI/CLOVER/config.plist，添加对应字段</p>
<pre><code>&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;
&lt;plist version&#x3D;&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;Devices&lt;&#x2F;key&gt;
    &lt;dict&gt;
        &lt;key&gt;AddProperties&lt;&#x2F;key&gt;
        &lt;array&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL,Gfx324&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                AQAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL,GfxYTile&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                AQAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelCycleDelay&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                +gAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerDown&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                PAAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerOff&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                EQAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerOn&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                GQEAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;AAPL00,PanelPowerUp&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                MAAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;graphic-options&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;data&gt;
                DAAAAA&#x3D;&#x3D;
                &lt;&#x2F;data&gt;
            &lt;&#x2F;dict&gt;
            &lt;dict&gt;
                &lt;key&gt;Device&lt;&#x2F;key&gt;
                &lt;string&gt;IntelGFX&lt;&#x2F;string&gt;
                &lt;key&gt;Key&lt;&#x2F;key&gt;
                &lt;string&gt;hda-gfx&lt;&#x2F;string&gt;
                &lt;key&gt;Value&lt;&#x2F;key&gt;
                &lt;string&gt;onboard-1&lt;&#x2F;string&gt;
            &lt;&#x2F;dict&gt;
        &lt;&#x2F;array&gt;
    &lt;&#x2F;dict&gt;
&lt;&#x2F;dict&gt;
&lt;&#x2F;plist&gt;</code></pre><blockquote>
<p>kexts</p>
</blockquote>
<p>复制 <code>FakeSMC.kext</code>, <code>RealtekRTL8111.kext</code>, <code>VoodooHDA.kext</code> 到 EFI/CLOVER／kexts／other</p>
<blockquote>
<p>ssd trim</p>
</blockquote>
<p>输入相关命令重启即可</p>
<pre><code>sudo trimforce enable</code></pre><blockquote>
<p>默认启动 </p>
</blockquote>
<p>config.plist／Boot/DefaultVolume 的 ‘值’ 改成你的启动盘(Sierra)，默认为 macHDD</p>
]]></description><link>http:/acyort.am0200.com/posts/205319771.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/205319771.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Fri, 17 Mar 2017 01:18:48 GMT</pubDate></item><item><title><![CDATA[Adobe CEP 扩展相关]]></title><description><![CDATA[<p>Adobe 系列通常情况下宿主应用是不会运行未经签名扩展的，只有打包并签名才可以运行。但是可以打开开发者模式</p>
<p>&lt;!-- more --&gt;
</p>
<h2>启用开发者模式</h2><blockquote>
<p>Windows</p>
</blockquote>
<p>打开到注册表定位到: ( 高版本类推 )</p>
<ul>
<li>CC 2014: <code>HKEY_CURRENT_USER\Software\Adobe\CSXS.5</code></li>
<li>CC 2015: <code>HKEY_CURRENT_USER\Software\Adobe\CSXS.6</code></li>
</ul>
<p>将 <code>PlayerDebugMode</code> 设置为 <code>1</code></p>
<blockquote>
<p>macOS</p>
</blockquote>
<p>终端输入: ( 同样高版本类推 )</p>
<p><code>defaults write com.adobe.CSXS.6 PlayerDebugMode 1</code></p>
<h2>扩展签名打包</h2><p>使用 Adobe 官方提供的 ZXPSignCmd
<a href="https://github.com/Adobe-CEP/CEP-Resources/tree/master/ZXPSignCMD">https://github.com/Adobe-CEP/CEP-Resources/tree/master/ZXPSignCMD</a></p>
<p><img src="https://cloud.githubusercontent.com/assets/2193211/21304385/cae9241a-c5ff-11e6-98fb-1ef0e84ee80e.png" alt="71097-6671c44f605ce86a"></p>
<p>以下为 macOS 下操作，Windows 类似。先进入文件目录</p>
<h3>创建证书</h3><pre><code>.&#x2F;ZXPSignCmd -selfSignedCert &lt;countryCode&gt; &lt;stateOrProvince&gt; &lt;organization&gt; &lt;commonName&gt; &lt;password&gt; &lt;outputPath.p12&gt;
.&#x2F;ZXPSignCmd -selfSignedCert &lt;国家代码&gt; &lt;地区&gt; &lt;组织名&gt; &lt;证书所有者名称&gt; &lt;证书密码&gt; &lt;证书名.p12&gt;

# example
.&#x2F;ZXPSignCmd -selfSignedCert CN guangzhou lorem.in loeify aksdj4 lorem.p12</code></pre><h3>签名并打包</h3><pre><code>.&#x2F;ZXPSignCmd -sign &lt;inputDirectory&gt; &lt;outputZxp&gt; &lt;p12&gt; &lt;p12Password&gt;
.&#x2F;ZXPSignCmd -sign &lt;要打包的项目目录&gt; &lt;输出文件路径&gt; &lt;证书路径&gt; &lt;证书密码&gt;

# example
.&#x2F;ZXPSignCmd -sign xxx xxx.zxp lorem.p12 aksdj4</code></pre><p>打包生成后的 <code>zxp</code> 是 <code>zip</code> 一样的可以解压</p>
<h2>手动安装插件</h2><h3>目录</h3><p>将插件解压，放进目录</p>
<blockquote>
<p>Windows</p>
</blockquote>
<p><code>C:\Program Files\Common Files\Adobe\CEP\extensions\</code></p>
<blockquote>
<p>macOS ( 注意是全局 Library，不是用户的 )</p>
</blockquote>
<p><code>/Library/Application Support/Adobe/CEP/extensions/</code></p>
<p>注意最终插件 xxx 放入目录最终应该存在 <code>/extensions/xxx/index.html</code></p>
<h3>启用</h3><p>重启 photoshop，选择 &quot;Window&quot; → &quot;Extensions&quot; → &quot;xxx&quot; 启用 </p>
<h2>参考文章</h2><ul>
<li><a href="http://nullice.com/archives/1741">Adobe CEP 扩展开发教程 「 4 」签名与打包</a></li>
<li><a href="http://nullice.com/archives/1665">Adobe CEP 扩展开发教程 「 1 」Hello World!</a></li>
</ul>
]]></description><link>http:/acyort.am0200.com/posts/196350551.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/196350551.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sun, 12 Feb 2017 11:58:28 GMT</pubDate></item><item><title><![CDATA[Mirror - 基于 issues 的博客工具]]></title><description><![CDATA[<p>Mirror 是一个简单的博客工具，基于 GitHub API 获取 issues 数据，然后展示在页面上。</p>
<p>该工具的方便之处在于只需要在 issue 上写你的博客文章，你的网站会自动更新博客内容。</p>
<p>借助 GitHub，你可以轻松的用 markdown 书写你的博客内容，永久保存，不用担心数据丢失问题。还可以非常方便上传博客图片，拖入编辑器即可。</p>
<p>该博客工具非常适合以 issue 作为自己博客的用户，无痛生成博客网站，对原来内容毫无影响</p>
<p>Mirror 还支持多用户协作，你可以方便的设置哪些用户写的内容可以显示在博客网站上，避免无关内容</p>
<p>Mirror 在移动端同时有很好的浏览体验</p>
<h2>预览地址</h2><p><a href="http://mirror.am0200.com/">http://mirror.am0200.com/</a></p>
<h2>项目地址</h2><p><a href="https://github.com/LoeiFy/Mirror">https://github.com/LoeiFy/Mirror</a></p>
<p>新版本使用 GitHub <a href="https://developer.github.com/v4/">GraphQL</a> API</p>
<p><code>REST API</code> 版本：<a href="https://github.com/LoeiFy/Mirror/tree/rest-api">https://github.com/LoeiFy/Mirror/tree/rest-api</a></p>
<p>Demo：<a href="http://mirror.am0200.com/rest-api/">http://mirror.am0200.com/rest-api/</a></p>
<p>更详细的介绍可以看项目说明</p>
<h2>如何安装</h2><p>安装很简单，需要一个 nodejs 环境，一个简单的命令即可，如果没有 nodejs 环境，可以直接下载资源包自己配置，后面会有说明</p>
<pre><code>$ sudo npm install Mirror -g</code></pre><h2>使用</h2><h3>新建</h3><pre><code>$ cd newblog
$ mirror init</code></pre><p>或者</p>
<pre><code>$ mirror init newblog</code></pre><p>完成后你的 blog 就在 newblog 这里</p>
<h3>配置你的 blog</h3><p>首先需要获取你的 access token，这个 token 只要只读权限</p>
<p><a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p>
<p>只需要勾选两个选择，其他不要勾选</p>
<ul>
<li>read:user Read all user profile data</li>
<li>user:email Access user email addresses (read-only)</li>
</ul>
<p>修改 <code>config.yml</code></p>
<pre><code># 标题
title: Mirror

# github 用户名
user: LoeiFy

# blog 内容来源 repo
repo: Recordum

# 多用户，设定哪些用户写的 issue 内容可以展示出来，项目的用户名会自动包括进来
# 多个用户用逗号（英文逗号）隔开，例如：user0,user1
authors: 

# token
# token 需要用 &#x60;#&#x60; 符号分割
# 例子: 5#c31bffc137f44faf7efc4a84da827g7ca2cfeaa
token:

# 分页
per_page: 10</code></pre><h3>生成博客</h3><pre><code>$ mirror build</code></pre><h3>发布你的 blog</h3><p>你可以添加域名到 <code>CNAME</code></p>
<p>push 文件到一个 repo 的 <code>gh-pages</code> 分支</p>
<p>参考例子：<a href="https://github.com/LoeiFy/Mirror/tree/gh-pages">https://github.com/LoeiFy/Mirror/tree/gh-pages</a></p>
<h3>最后</h3><p>现在你可以在 github issue  上写博客了，内容会同步更新</p>
<blockquote>
<p>一个例子</p>
</blockquote>
<p>在 <a href="https://github.com/LoeiFy/Recordum/issues">https://github.com/LoeiFy/Recordum/issues</a> 这个 issue 上写博客内容，对应网站 <a href="http://mirror.am0200.com/">http://mirror.am0200.com/</a> 会自动同步更新内容</p>
<h2>另一种安装方式</h2><p>你可以直接下载资源包，下载最新的 release，然后打开 <code>index.html</code> 进行配置，按照例子进行配置即可</p>
<p><a href="https://github.com/LoeiFy/Mirror/raw/master/mirror.zip">https://github.com/LoeiFy/Mirror/raw/master/mirror.zip</a></p>
<pre><code>&lt;!-- index.html --&gt;

&lt;script&gt;
&#x2F;*
**
** blog config here
** token should be separated by &#39;#&#39;.
** example: 5#c31bffc137f44faf7efcs4544da827g7ca2cfeaa
** muti-authors should be separated by &#39;,&#39;. and the user is included in.
** example: &#39;LoeiFy, author0&#39;
**
*&#x2F;

window.config &#x3D; {&quot;title&quot;:&quot;&quot;,&quot;user&quot;:&quot;&quot;,&quot;repository&quot;:&quot;&quot;,&quot;authors&quot;:&quot;&quot;,&quot;perpage&quot;:&quot;&quot;,&quot;token&quot;:&quot;&quot;}
&lt;&#x2F;script&gt;</code></pre><p>配置好后，可以先尝试本地预览，需要一个本地服务器，放上去访问 <code>index.html</code> 即可，测试没问题就可以把全部文件上传到对应地址即可，也可以放到 GitHub pages 上</p>
<h2>名字来源</h2><p><code>Mirror</code> 是 <code>DJ Okawari</code> 所作的专辑</p>
<p><img src="https://cloud.githubusercontent.com/assets/2193211/12321915/c66d8b12-baeb-11e5-9612-b188f5272e3b.jpg" alt="mirror"></p>
]]></description><link>http:/acyort.am0200.com/posts/126817142.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/126817142.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 16 Dec 2017 07:08:42 GMT</pubDate></item><item><title><![CDATA[输入框输入值自动格式化]]></title><description><![CDATA[<p>这里说的自动格式化是指当用户在输入框里面输入数字，例如银行卡号，为了方便用户输入，希望在输入过程中对输入数字进行加空格处理，优化用户体验</p>
<p>&lt;!-- more --&gt;
</p>
<p>先看一下例子: <a href="http://jsfiddle.net/am0200/qugp8tvL/">http://jsfiddle.net/am0200/qugp8tvL/</a></p>
<p>注意例子里面的输入框的类型是 <code>tel</code>，而不是 <code>number</code>，主要原因是 <code>number</code> 类型</p>
<ul>
<li>会导致 Android 上某些系统不显示 <code>placeholder</code></li>
<li>无法插入非数字内容，例如空格</li>
</ul>
<h3>代码实现</h3><p><code>data-gap</code> 代表第几位开始加空格，不为 0</p>
<pre><code>&lt;input data-gap&#x3D;4 maxlength&#x3D;&quot;24&quot; size&#x3D;&quot;30&quot; autocomplete&#x3D;&quot;off&quot; type&#x3D;&quot;tel&quot; placeholder&#x3D;&quot;请输入卡号&quot;&#x2F;&gt;</code></pre><p>原理就是获取用户输入内容，格式化处理完成后再填入输入框</p>
<pre><code>var input &#x3D; document.querySelectorAll(&#39;input&#39;)[0]
var gap &#x3D; parseInt(input.getAttribute(&#39;data-gap&#39;))

input.oninput &#x3D; function() {
  var numbers &#x3D; this.value.replace(&#x2F;\s+&#x2F;g, &#39;&#39;).split(&#39;&#39;)     &#x2F;&#x2F; 获取原始值
  var back &#x3D; &#39;&#39; 

  numbers.forEach(function(n, i) {
    back +&#x3D; n + ((i + 1) % gap &#x3D;&#x3D;&#x3D; 0 ? &#39; &#39; : &#39;&#39;)    &#x2F;&#x2F; 处理加空格
  })

  var len &#x3D; back.length
  var last &#x3D; back.charAt(len - 1)

  if (last &#x3D;&#x3D;&#x3D; &#39; &#39; || isNaN(last)) {
    back &#x3D; back.substring(0, len - 1)    &#x2F;&#x2F; 移除末尾无用字符
  }

  this.value &#x3D; back

  &#x2F;&#x2F; 兼容处理
  setTimeout(function() {
    this.setSelectionRange(len, len)
    this.focus()
  }.bind(this), 0)
}</code></pre><p>获取输入原始值</p>
<pre><code>input.value.replace(&#x2F;\s+&#x2F;g, &#39;&#39;)</code></pre><h3>扩展</h3><p>可以设置格式化分割字符，例如用 <code>-</code> 代替空格，还可以设定不规则位数空格，具体可以修改处理条件即可</p>
]]></description><link>http:/acyort.am0200.com/posts/71470122.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/71470122.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Mon, 18 Dec 2017 08:49:25 GMT</pubDate></item><item><title><![CDATA[创建类似 http://ithinkimight.com/ 随机大小排布界面]]></title><description><![CDATA[<p><code>ithinkimight.com</code> 这个网站图片来自 Instagram，图片随机大小，位置也是随机，图片可以重叠，但是并没有 <strong>过分</strong> 重叠。这种随机大小，位置排版页面元素跟平常的整齐 <code>grid</code> 或者 <code>瀑布流</code> 风格很不一样，下面我们尝试一下实现类似效果</p>
<p>&lt;!-- more --&gt;
</p>
<p>从网站源文件上看并不能看出网站是如何随机排布这些图片，因为是后端直接输出图片的位置参数，并不是前端实现的位置计算。不过这里有一种简单方法，可以实现类似效果。先看一下具体效果</p>
<h3>例子以及实际运用效果</h3><p><a href="http://jsfiddle.net/am0200/1mn5xbf8/">http://jsfiddle.net/am0200/1mn5xbf8/</a></p>
<p><a href="http://stone.am0200.com/">http://stone.am0200.com/</a></p>
<h3>实现思路</h3><p>首先把 container 划分为 4 个块，然后需要随机定位的 4 个块分别放到这 4 个区域，最后定义这 4 个块距离左边跟上边的最远，最近距离即可</p>
<h3>实现代码</h3><p>html 部分，我们只是生成 4 个容器，每个容器都可以放置一张图片</p>
<pre><code>&lt;section&gt;
    &lt;div id&#x3D;&quot;d0&quot;&gt;&lt;&#x2F;div&gt;
    &lt;div id&#x3D;&quot;d1&quot;&gt;&lt;&#x2F;div&gt;
    &lt;div id&#x3D;&quot;d2&quot;&gt;&lt;&#x2F;div&gt;
    &lt;div id&#x3D;&quot;d3&quot;&gt;&lt;&#x2F;div&gt;
&lt;&#x2F;section&gt;</code></pre><p>css 部分，我们使用绝对定位来设置每个容器的主要位置</p>
<pre><code>section {
    width: 100%;
    height: 100%;
    position: relative;
}
section div {
    position: absolute;
}
#d0 {
    left: 50%;
    top: 0;
}
#d1 {
    top: 50%;
    left: 50%;
}
#d2 {
    left: 0;
    top: 50%;
}
#d3 {
    left: 0;
    top: 0;
}</code></pre><p>js 部分，我们设置 4 个块随机大小，并且随机上下左右距离，需要注意的是，这个距离是有一定的范围的</p>
<pre><code>function rd(n,m){
    var c &#x3D; m-n+1;  
    return Math.floor(Math.random() * c + n);
}

var w &#x3D; parseInt($(&#39;section&#39;).width()),
    h &#x3D; parseInt($(&#39;section&#39;).height());

$(&#39;div&#39;).each(function() {
    var wh &#x3D; rd(150, 200)
    $(this).css({
        width: wh,
        height: wh
    })
})

var d0 &#x3D; parseInt($(&#39;#d0&#39;).width()),
    d1 &#x3D; parseInt($(&#39;#d1&#39;).width()),
    d2 &#x3D; parseInt($(&#39;#d2&#39;).width()),
    d3 &#x3D; parseInt($(&#39;#d3&#39;).width());

var a1 &#x3D; rd(-(d0 &#x2F; 4), w &#x2F; 2 - d0),
    a2 &#x3D; rd(0, h &#x2F; 2 - d0 &#x2F; 4 * 3);

var b1 &#x3D; rd(-(d1 &#x2F; 4), w &#x2F; 2 - d1),
    b2 &#x3D; rd(-(d1 &#x2F; 4), h &#x2F; 2 - d1);

var c1 &#x3D; rd(0, w &#x2F; 2 - d2 &#x2F; 4 * 3),
    c2 &#x3D; rd(-(d2 &#x2F; 4), h &#x2F; 2 - d2);    

var e1 &#x3D; rd(0, w &#x2F; 2 - d3 &#x2F; 4 * 3),
    e2 &#x3D; rd(0, h &#x2F; 2 - d3 &#x2F; 4 * 3); 


$(&#39;#d0&#39;).css(&#39;margin-left&#39;, a1 +&#39;px&#39;)
$(&#39;#d0&#39;).css(&#39;margin-top&#39;, a2 +&#39;px&#39;)

$(&#39;#d1&#39;).css(&#39;margin-left&#39;, b1 +&#39;px&#39;)
$(&#39;#d1&#39;).css(&#39;margin-top&#39;, b2 +&#39;px&#39;)

$(&#39;#d2&#39;).css(&#39;margin-left&#39;, c1 +&#39;px&#39;)
$(&#39;#d2&#39;).css(&#39;margin-top&#39;, c2 +&#39;px&#39;)

$(&#39;#d3&#39;).css(&#39;margin-left&#39;, e1 +&#39;px&#39;)
$(&#39;#d3&#39;).css(&#39;margin-top&#39;, e2 +&#39;px&#39;)</code></pre><h3>其他问题</h3><p>这种定位简单方便，但是如果是单数块的时候，就要做一下相关处理了</p>
]]></description><link>http:/acyort.am0200.com/posts/71329290.html</link><guid isPermaLink="true">http:/acyort.am0200.com/posts/71329290.html</guid><dc:creator><![CDATA[LoeiFy]]></dc:creator><pubDate>Sat, 16 Dec 2017 07:09:01 GMT</pubDate></item></channel></rss>